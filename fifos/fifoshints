HOW TO GET PIC AND PIT

1) first setup the GDT
	.gdt section in loader.S

	.globl stack, IDT

	.bss
	.align 0x1000
	.comm stack, 0x1000
	.comm IDT, 0x800

	; save multiboot pointer
	pushl %ebx

	; set up IDT
	movl $IDT, %edi
	movl $0x30, %ecx
	movl $0x080000, %edi	; segment selector kernel code segment, last two bytes dont matter for IDT
	movl $int_table, %esi	; this is the large table of pointers
1:
	lodsl					; DS:ESI --> EAX
	movw %ax, %dx			; lower 16 bits of table address goes to dx
	movw $0xEE00, %ax		; DPL = 3 (should be 0 for ring 0)
	movl %edx, (%edi)		; store bottom 32 bits of descriptor in EDX into IDT
	addl $4, %edi			; 
	stosl
	loop 1b
	lidt idt_ptr			; base address of IDT table + the size of the IDT

	call init



	....

	another way to do this


gdt:
	; the first two have to be null for safety reasons
	.long 0
	.long 0

	; then comes the kernel CS
	.long 0x0000FFFF
	.long 0x00CF9A00

	; then the kernel DS
	.long 0x0000FFFF
	.long 0x00CF9200

gdt_ptr:
	; GDT is 48 Bytes - 16 for size, 32 for location
	.short 0x17			; size of te gdt here (in this case, 3 entries)
	.long gdt			; pointer to the gdt is the second arg

real_start:
	lgdt gdt_ptr		; first we load the gdt
	ljmp $0x08, $1f		; force reload all segment regs
	; 8 here is (1 << 3) the first entry in the GDT (K CS)
1:
	; now we do the same for the data segments
	movw $0x10, %ax ; this changes the segment to the K DS
	movw %ax, %ss
	movw %ax, %ds
	movw %ax, %es
	movw %ax, %fs
	movw %ax, %gs

	; rest of the loader code


2) Set up the IDT
	// in real mode this would be called the IVT
	// struct IDT here -> https://wiki.osdev.org/Interrupt_Descriptor_Table
	// first 32 (number 0 to 31) IDTs are resreved for hardware faults and traps
	// we have accesss to the rest of the IDT (number 32 to 255)

struct _IDT_p
{
	uint16_t size;
	IDTDesc * des;
};
	// in the init routine for the kernel
	// IDT[32] is the timer

	// set it up this way
	IDT[32].offset_1 = (uint32_t) &timer & 0xFFFF;
	IDT[32].offset_2 = (uint32_t) &timer >> 16;
	IDT[32].zeros = 0x0;
	IDT[32].selector = 0x08;
	IDT[32].type_attr = 0xEE;

	// fill in the IDT poitner
	IDT_p.size = 0x7FF;
	IDT_p.des = &IDT[0];

	__asm__ volatile ("lidt (IDT_p)");

	// then do the rest of the memory map walks

	in interrupt.S
	{
		timer:
			call handle_timer
			iret
	}

	// after this we can recv a timer intterupt, but no way to handle it
	// we have so far registered a timer handler

	// then in the the kernel code, aftet the mmap processing
	init_pic();
	init_pit();


3) Setting up the PIC

in interrupt.c

we have out outb function
static inline void
outb(uint8_t value, uint16_t port)
{
	__asm__ volatile("outb %0, %1" :: "a" (value), "Nd" (port)); 
}

void
init_pic(void)
{
	// 0x11 is the init command for command port for PIC 1, which has the address port 0x20
	// ref -> https://wiki.osdev.org/8259_PIC
	outb(0x11, 0x20);

	// next thing the PIC looks for is the IRQ offset in the IDT
	// PIC1_BASE_IRQ = 0x20 which is the entry in the IDT for the timer
	// So we are just setting up IRQ 0 in the PIC as IDT 32 in the CPU
	// When line 0 fires in the PIC, it will raise IDT 32 = 0x20 in the CPU
	// 0x21 is just a command number for the PIC
	outb(PIC1_BASE_IRQ, 0x21);

	// similarly, the second PIC can be initialized at PIC2_BASE_IRQ 0x28
}


4) Setting up the PIT
	// ref -> osdev PIT
#define PIT_FREQ 1193182
#define RATE 100

void
init_pit()
{
	// init
	outb(0x34, 0x43);

	// devide by the number of times (RATE) we want it to go off
	outb((PIT_FREQ / RATE) & 0xFF, 0x40);
	outb((PIT_FREQ / RATE) >> 8, 0x40);	
}


// to signal the end of the interupt, we have to write 0x20 to 0x20
void
send_eoi(void)
{
	outb(0x20, 0x20);
}


// so the strucuture of a handler becomes
void
handle_timer(void)
{
	/* handle shit */

	send_eoi();
}
